# Debian-WS Development Instructions

## Overview

This document provides detailed instructions for developing and maintaining the Debian-WS project. Follow these guidelines to ensure consistency and quality across the codebase.

## Development Workflow

### 1. Function Development

All new functionality must be implemented as functions in the appropriate library files:

- **System-level functions**: `lib/core/`
- **Installation functions**: `lib/install/`
- **Configuration functions**: `lib/config/`

### 2. Code Structure Template

```bash
#!/bin/bash
# Description: Brief description of the script
# Author: Generated by GitHub Copilot for Debian-WS
# License: MIT

set -euo pipefail

# Source required libraries
source "$(dirname "$0")/../lib/core/logging.sh"
source "$(dirname "$0")/../lib/core/system.sh"

# Function documentation
# Description: What this function does
# Args:
#   $1 - First parameter description
#   $2 - Second parameter description (optional)
# Returns: Exit code (0 = success, 1 = error)
# Globals:
#   DEBIANWS_* - Environment variables used
function_name() {
    local param1="$1"
    local param2="${2:-default_value}"

    # Function implementation
    log_info "Starting function_name with param1: $param1"

    # Error handling example
    if ! some_command; then
        log_error "Failed to execute some_command"
        return 1
    fi

    log_success "Function completed successfully"
    return 0
}

# Main execution (if script is run directly)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    function_name "$@"
fi
```

### 3. Library Functions

#### Core Libraries (`lib/core/`)

**system.sh** - System detection and utilities
```bash
check_debian_version()     # Verify Debian 12+
check_gnome_session()      # Verify GNOME/GDM3
check_root_privileges()    # Check sudo/root access
get_system_info()         # Gather system information
```

**logging.sh** - Logging and user feedback
```bash
log_info()     # Information messages
log_success()  # Success messages
log_warning()  # Warning messages
log_error()    # Error messages
log_debug()    # Debug messages (when DEBUG=1)
```

**package.sh** - Package management
```bash
update_package_cache()     # Update apt cache
install_package()          # Install single package
install_packages()         # Install multiple packages
remove_package()           # Remove package
check_package_installed()  # Check if package exists
```

**network.sh** - Network operations
```bash
check_internet_connection()  # Test connectivity
download_file()              # Download with verification
setup_dns()                  # Configure DNS
test_repository_access()     # Test apt repository access
```

#### Installation Libraries (`lib/install/`)

**apt.sh** - APT package management
```bash
add_repository()           # Add apt repository
add_gpg_key()             # Add GPG key to keyring
install_from_deb()        # Install .deb file
setup_backports()         # Configure backports
```

**flatpak.sh** - Flatpak management
```bash
setup_flatpak()           # Initialize Flatpak
add_flathub()             # Add Flathub repository
install_flatpak_app()     # Install Flatpak application
check_flatpak_available() # Check if app exists on Flathub
list_flatpak_apps()      # List installed Flatpak apps
```

**external.sh** - External downloads
```bash
download_github_release()  # Download from GitHub releases
install_appimage()         # Install AppImage
install_binary()           # Install standalone binary
install_from_deb_url()     # Download and install .deb file
```

#### Application Installation Strategy

**Terminal Applications** (`install/terminal/`)
- Use APT packages for system tools
- External downloads for specialized tools
- Manual builds for cutting-edge tools

**Desktop Applications** (`install/desktop/`)
- **Primary**: Flatpak from Flathub (sandboxed, auto-updates)
- **Secondary**: APT packages (when Flatpak unavailable)
- **Tertiary**: External .deb files (vendor-specific)
- **Last resort**: Snap packages

**Flatpak Installation Pattern**:
```bash
# Desktop application installation template
install_desktop_application() {
    local app_name="$1"
    local flatpak_id="$2"
    local apt_package="$3"
    local deb_url="$4"

    log_info "Installing $app_name..."

    # Try Flatpak first (preferred for desktop apps)
    if [[ -n "$flatpak_id" ]] && check_flatpak_available "$flatpak_id"; then
        if install_flatpak_app "$flatpak_id"; then
            log_success "$app_name installed via Flatpak"
            return 0
        fi
    fi

    # Fallback to APT package
    if [[ -n "$apt_package" ]] && check_package_available "$apt_package"; then
        log_info "Flatpak unavailable, using APT: $apt_package"
        if install_package "$apt_package"; then
            log_success "$app_name installed via APT"
            return 0
        fi
    fi

    # Last resort: external .deb
    if [[ -n "$deb_url" ]]; then
        log_info "Package managers unavailable, downloading .deb"
        if install_from_deb_url "$app_name" "$deb_url"; then
            log_success "$app_name installed from external source"
            return 0
        fi
    fi

    log_error "Failed to install $app_name through any method"
    return 1
}
```

#### Configuration Libraries (`lib/config/`)

**gnome.sh** - GNOME configuration
```bash
configure_gnome_settings()  # Apply GNOME settings
install_gnome_extensions()  # Install extensions
setup_gnome_theme()        # Apply themes
```

**terminal.sh** - Terminal configuration
```bash
setup_alacritty()          # Configure Alacritty
setup_bash_profile()       # Configure bash
install_terminal_tools()   # Install CLI tools
```

### 4. Error Handling Standards

All functions must implement proper error handling:

```bash
# Example error handling pattern
function_name() {
    local param="$1"

    # Validate parameters
    if [[ -z "$param" ]]; then
        log_error "Parameter required"
        return 1
    fi

    # Execute with error checking
    if ! command_that_might_fail "$param"; then
        log_error "Command failed: command_that_might_fail"
        return 1
    fi

    # Success
    return 0
}
```

### 5. Testing Guidelines

- Test all functions individually
- Test with various Debian versions (focus on 12+)
- Test both fresh installs and existing systems
- Test error conditions and recovery
- Verify idempotent behavior

### 6. Documentation Requirements

Every function must include:
- Purpose description
- Parameter documentation
- Return value specification
- Usage examples
- Error conditions

### 7. Security Best Practices

- Always validate user inputs
- Use full paths for executables
- Implement proper privilege checking
- Sanitize environment variables
- Use secure download methods (HTTPS + verification)

### 8. Compatibility Guidelines

- Support Debian 12+ only
- Require GNOME/GDM3 desktop environment
- Maintain compatibility with existing debian-ok configurations
- Follow XDG Base Directory Specification
- Use systemd for service management

### 9. Release Process

1. Test all functionality on clean Debian 12 installation
2. Update version information
3. Update documentation
4. Create release notes
5. Tag release in Git
6. Update installation scripts

### 10. Contribution Guidelines

- Follow the function-based architecture
- Include comprehensive error handling
- Add appropriate logging
- Update documentation
- Test thoroughly before submitting
- Follow existing code style conventions

## Environment Variables

The project uses these standard environment variables:

- `DEBIANWS_VERSION` - Current version
- `DEBIANWS_CONFIG_DIR` - Configuration directory
- `DEBIANWS_LOG_LEVEL` - Logging verbosity
- `DEBIANWS_SKIP_PROMPTS` - Automated installation mode
- `DEBUG` - Enable debug output

## Integration with External Projects

When integrating with external projects like Chris Titus configurations:
- Always credit the original source
- Maintain compatibility with upstream changes
- Implement fallbacks for unavailable resources
- Document any modifications made to external configurations
